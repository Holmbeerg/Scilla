Here we first rotate the container around the origin (0,0,0) and once it's rotated, we translate its
rotated version to the bottom-right corner of the screen. Remember that the actual transformation order
should be read in reverse: even though in code we first translate and then later rotate, the actual transformations
first apply a rotation and then a translation.Here we first rotate the container around the origin (0,0,0) and
once it's rotated, we translate its rotated version to the bottom-right corner of the screen. Remember that the
actual transformation order should be read in reverse: even though in code we first translate and then later rotate
the actual transformations first apply a rotation and then a translation.

glm::mat4 trans = glm::mat4(1.0f);
trans = glm::translate(trans, glm::vec3(0.5f, -0.5f, 0.0f));
trans = glm::rotate(trans, static_cast<float>(tan(glfwGetTime())), glm::vec3(2.0f, 0.5f, 1.0f));
GLuint transformLocation = glGetUniformLocation(shaderProgram2.getId(), "transform");
glUniformMatrix4fv(transformLocation, 1, GL_FALSE, glm::value_ptr(trans));

https://stackoverflow.com/questions/59222806/how-does-glm-handle-translation
1. We give as input a matrix (in this case IDENTITY MATRIX)
2. A translation matrix is formed based on given translation vector. Travel a distance of 1 along x-axis, 1 along y-axis and 0 along z-axis.
3. Multiply input matrix  with formed translation matrix and return. Return resulting matrix.
inputMatrix = glm::translate(inputMatrix, glm::vec3(1.0f, 1.0f, 0.0f));

glm::vec4 vec(1.0f, 0.0f, 0.0f, 1.0f); // define a vector
glm::mat4 inputMatrix = glm::mat4(1.0f); // initialize a matrix, IDENTITY MATRIX with 1.0f
inputMatrix = glm::scale(inputMatrix, glm::vec3(0.5f, 0.5f, 0.5f)); // scale the container by 0.5 on each axis
inputMatrix = glm::rotate(inputMatrix, glm::radians(90.0f), glm::vec3(0.0f, 0.0f, 1.0f)); // rotate by 90 degrees around the z-axis

glm::mat4 model(1.0f); // identity matrix
model = glm::rotate(model, glm::radians(-55.0f), glm::vec3(1.0f, 0.0f, 0.0f)); // rotate around the x-axis
= By multiplying the vertex coordinates with this model matrix we're transforming the vertex coordinates to world coordinates.
Our plane that is slightly on the floor thus represents the plane in the global world.

auto trans = glm::mat4(1.0f);
trans = glm::translate(trans, glm::vec3(0.5f, -0.5f, 0.0f));
trans = glm::rotate(trans, static_cast<float>(tan(glfwGetTime())), glm::vec3(2.0f, 0.5f, 1.0f));
const GLint transformLocation = glGetUniformLocation(shaderProgram2.getId(), "transform");
glUniformMatrix4fv(transformLocation, 1, GL_FALSE, glm::value_ptr(trans));