Here we first rotate the container around the origin (0,0,0) and once it's rotated, we translate its
rotated version to the bottom-right corner of the screen. Remember that the actual transformation order
should be read in reverse: even though in code we first translate and then later rotate, the actual transformations
first apply a rotation and then a translation.Here we first rotate the container around the origin (0,0,0) and
once it's rotated, we translate its rotated version to the bottom-right corner of the screen. Remember that the
actual transformation order should be read in reverse: even though in code we first translate and then later rotate
the actual transformations first apply a rotation and then a translation.

glm::mat4 trans = glm::mat4(1.0f);
trans = glm::translate(trans, glm::vec3(0.5f, -0.5f, 0.0f));
trans = glm::rotate(trans, static_cast<float>(tan(glfwGetTime())), glm::vec3(2.0f, 0.5f, 1.0f));
GLuint transformLocation = glGetUniformLocation(shaderProgram2.getId(), "transform");
glUniformMatrix4fv(transformLocation, 1, GL_FALSE, glm::value_ptr(trans));

https://stackoverflow.com/questions/59222806/how-does-glm-handle-translation
1. We give as input a matrix (in this case IDENTITY MATRIX)
2. A translation matrix is formed based on given translation vector. Travel a distance of 1 along x-axis, 1 along y-axis and 0 along z-axis.
3. Multiply input matrix  with formed translation matrix and return. Return resulting matrix.
inputMatrix = glm::translate(inputMatrix, glm::vec3(1.0f, 1.0f, 0.0f));

rotate 90 degrees around z-axis, glm::radians takes degrees and gives radians
inputMatrix = glm::rotate(inputMatrix, glm::radians(90.0f), glm::vec3(0.0f, 0.0f, 1.0f));

